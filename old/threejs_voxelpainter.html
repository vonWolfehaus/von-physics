<!DOCTYPE html>
<html lang="en">
<head>
<title>three.js webgl - interactive - voxel painter</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<style>
	body {
		background-color: #f0f0f0;
		margin: 0px;
		overflow: hidden;
		position: fixed;
		width: 100%;
		height: 100%;
	}
	.info {
		position: absolute;
		top: 10px;
		width: 100%;
		text-align: center;
	}
	#oldie { background-color: #ddd !important }
</style>
</head>
<body>

	<div class="info"><a href="http://threejs.org" target="_blank">three.js</a> - voxel painter - webgl<br>
		<strong>click</strong>: add voxel, <strong>control + click</strong>: remove voxel, <strong>shift</strong>: rotate
	</div>

<script src="src/lib/three.min.js"></script>
<script src="src/lib/Detector.js"></script>
<script src="src/lib/stats.min.js"></script>

<script src="src/Manifold.js"></script>
<script src="src/AABB3.js"></script>
<script src="src/geom/Cube.js"></script>

<script>
if (!Detector.webgl) {
	Detector.addGetWebGLMessage();
	return;
}
var von = von || {};

// GLOBALS
von.gravity = 5;
von.friction = 0.98;

(function(){
	var container, stats;
	var camera, scene, renderer;
	var projector, plane, cube;
	var mouse2D, mouse3D, raycaster,
		_mark, total = 0, objects = [],
		rollOveredFace, isShiftDown = false,
		theta = 45 * 0.5, isCtrlDown = false;

	var rollOverMesh, rollOverMaterial;
	var voxelPosition = new THREE.Vector3(), tmpVec = new THREE.Vector3(), normalMatrix = new THREE.Matrix3();
	var cubeGeo, cubeMaterial;
	var i, intersector;
	
	/**********************
	 * Setup, threejs
	 */
	
	init();
	update();

	function init() {
		container = document.createElement( 'div' );
		document.body.appendChild( container );

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.y = 800;
		
		/*camera = new THREE.OrthographicCamera( window.innerWidth / - 2, window.innerWidth / 2, window.innerHeight / 2, window.innerHeight / - 2, 100, 3000 );
		camera.position.x = 200;
		camera.position.y = 700;
		camera.position.z = 100;*/

		scene = new THREE.Scene();

		// roll-over helpers
		rollOverGeo = new THREE.CubeGeometry( 50, 50, 50 );
		rollOverMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
		rollOverMesh = new THREE.Mesh( rollOverGeo, rollOverMaterial );
		scene.add( rollOverMesh );

		// cubes
		cubeGeo = new THREE.CubeGeometry( 50, 50, 50 );
		cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c, ambient: 0x00ff80, shading: THREE.FlatShading, map: THREE.ImageUtils.loadTexture( 'img/square-outline-textured.png' ) } );
		cubeMaterial.ambient = cubeMaterial.color;

		// picking
		projector = new THREE.Projector();

		// grid
		plane = new THREE.Mesh( new THREE.PlaneGeometry( 1000, 1000, 20, 20 ), new THREE.MeshBasicMaterial( { color: 0x555555, wireframe: true } ) );
		plane.rotation.x = - Math.PI / 2;
		scene.add( plane );

		mouse2D = new THREE.Vector3( 0, 10000, 0.5 );

		// Lights
		var ambientLight = new THREE.AmbientLight( 0x606060 );
		scene.add( ambientLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
		scene.add( directionalLight );

		renderer = new THREE.WebGLRenderer( { antialias: true, preserveDrawingBuffer: true } );
		renderer.setSize( window.innerWidth, window.innerHeight );

		container.appendChild( renderer.domElement );

		stats = new Stats();
		stats.domElement.style.position = 'absolute';
		stats.domElement.style.top = '0px';
		container.appendChild( stats.domElement );

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mousedown', onDocumentMouseDown, false );
		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );

		window.addEventListener( 'resize', function onWindowResize() {
			camera.aspect = window.innerWidth / window.innerHeight;
			camera.updateProjectionMatrix();
			renderer.setSize( window.innerWidth, window.innerHeight );
		}, false );
		
		_mark = window.performance.now();
	}

	function getRealIntersector( intersects ) {
		for( i = 0; i < intersects.length; i++ ) {
			intersector = intersects[ i ];
			if ( intersector.object != rollOverMesh ) {
				return intersector;
			}
		}
		return null;
	}

	function setVoxelPosition( intersector ) {
		normalMatrix.getNormalMatrix( intersector.object.matrixWorld );
		
		tmpVec.copy( intersector.face.normal );
		tmpVec.applyMatrix3( normalMatrix ).normalize();

		voxelPosition.addVectors( intersector.point, tmpVec );

		voxelPosition.x = Math.floor( voxelPosition.x / 50 ) * 50 + 25;
		voxelPosition.y = Math.floor( voxelPosition.y / 50 ) * 50 + 25;
		voxelPosition.z = Math.floor( voxelPosition.z / 50 ) * 50 + 25;
	}

	function onDocumentMouseMove( evt ) {
		evt.preventDefault();
		mouse2D.x = ( evt.clientX / window.innerWidth ) * 2 - 1;
		mouse2D.y = - ( evt.clientY / window.innerHeight ) * 2 + 1;
	}

	function onDocumentMouseDown( evt ) {
		evt.preventDefault();
		var intersects = raycaster.intersectObjects( scene.children );
		if ( intersects.length > 0 ) {
			intersector = getRealIntersector( intersects );
			// delete cube
			if ( isCtrlDown ) {
				if ( intersector.object != plane ) {
					scene.remove( intersector.object );
				}
			// create cube
			} else {
				intersector = getRealIntersector( intersects );
				setVoxelPosition( intersector );

				var voxel = new THREE.Mesh( cubeGeo, cubeMaterial );
				voxel.position.copy( voxelPosition );
				voxel.matrixAutoUpdate = false;
				voxel.updateMatrix();
				scene.add( voxel );
				
				var tile = new von.Cube(voxelPosition.x, voxelPosition.y, voxelPosition.z);
				tile.dynamic = false;
				tile.hull.setMass(0);
				objects.push();
			}
		}
	}

	function onDocumentKeyDown( evt ) {
		switch( evt.keyCode ) {
			case 16: isShiftDown = true; break;
			case 17: isCtrlDown = true; break;
		}
	}

	function onDocumentKeyUp( evt ) {
		switch ( evt.keyCode ) {
			case 16: isShiftDown = false; break;
			case 17: isCtrlDown = false; break;
		}
	}

	function update() {
		var now = window.performance.now(),
			dt = now - _mark;
		
		_mark = now;
		von.elapsed = dt * 0.001;
		
		// motion and input
		var j, a, b;
		for (i = 0; i < total; ++i) {
			objects[i].update();
		}
		
		// physics
		var m;
		for (i = 0; i < (total-1); ++i) {
			a = objects[i];
			
			for (j = i + 1; j < total; ++j) {
				b = objects[j];
				
				// if (a.dynamic || b.dynamic) m = overlapAABB(a, b); // only check collisions for moving objects
				m = overlapAABB(a, b);
				if (m) resolveCollision(a, b, m);
			}
		}
		
		render();
		stats.update();
		
		requestAnimationFrame(update);
	}

	function render() {
		if ( isShiftDown ) {
			theta += mouse2D.x * 1.5;
		}

		raycaster = projector.pickingRay( mouse2D.clone(), camera );
		var intersects = raycaster.intersectObjects( scene.children );
		if ( intersects.length > 0 ) {
			intersector = getRealIntersector( intersects );
			if ( intersector ) {
				setVoxelPosition( intersector );
				rollOverMesh.position = voxelPosition;
			}
		}

		camera.position.x = 1400 * Math.sin( THREE.Math.degToRad( theta ) );
		camera.position.z = 1400 * Math.cos( THREE.Math.degToRad( theta ) );
		camera.lookAt( scene.position );
		renderer.render( scene, camera )
	}
	
	
}());
</script>
</body>
</html>
